<!DOCTYPE html>
<html>
<head>
    <title>Figma Plugin API Proxy - Fixed v2.4.1</title>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #f0f0f0;
        }
        .loading {
            text-align: center;
            padding: 20px;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007acc;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .version {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 12px;
            color: #666;
            background: rgba(255,255,255,0.8);
            padding: 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="version">v2.4.1-fixed</div>
    <div class="loading">
        <div class="spinner"></div>
        <p>æ­£åœ¨å¤„ç†APIè¯·æ±‚...</p>
    </div>

    <script>
        console.log('ğŸŒ APIä»£ç†é¡µé¢v2.4.1å·²åŠ è½½');
        
        // å®šä¹‰å¤šä¸ªCORSä»£ç†ï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åº
        const CORS_PROXIES = [
            {
                name: 'proxy.cors.sh',
                url: 'https://proxy.cors.sh/',
                headers: {}
            },
            {
                name: 'cors.bridged.cc', 
                url: 'https://cors.bridged.cc/',
                headers: {}
            },
            {
                name: 'corsfix.com',
                url: 'https://api.corsfix.com/',
                headers: {
                    'X-Cors-Api-Key': 'temp_key'
                }
            }
        ];

        // ç›‘å¬æ¥è‡ªFigmaæ’ä»¶çš„æ¶ˆæ¯
        window.addEventListener('message', async (event) => {
            console.log('ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯v2.4.1:', event.data);
            
            if (event.data && event.data.type === 'API_REQUEST') {
                console.log('ğŸš€ å¼€å§‹å¤„ç†APIè¯·æ±‚...');
                
                try {
                    let result;
                    
                    // æ™ºèƒ½æ£€æµ‹æ¶ˆæ¯æ ¼å¼
                    if (event.data.apiUrl) {
                        // æ–°æ ¼å¼ï¼š{type: 'API_REQUEST', apiUrl: '...', headers: {...}, body: {...}}
                        console.log('âœ… æ£€æµ‹åˆ°æ–°æ ¼å¼æ¶ˆæ¯');
                        const { apiUrl, headers, body } = event.data;
                        result = await processNewFormat(apiUrl, headers, body);
                    } else if (event.data.payload) {
                        // æ—§æ ¼å¼ï¼š{type: 'API_REQUEST', payload: {...}}
                        console.log('âœ… æ£€æµ‹åˆ°æ—§æ ¼å¼æ¶ˆæ¯');
                        result = await processOldFormat(event.data.payload);
                    } else {
                        throw new Error('æ— æ•ˆçš„æ¶ˆæ¯æ ¼å¼ï¼šç¼ºå°‘apiUrlæˆ–payload');
                    }
                    
                    // å‘é€æˆåŠŸå“åº”
                    sendSuccessResponse(result);
                    
                } catch (error) {
                    console.error('âŒ APIè¯·æ±‚å¤±è´¥:', error);
                    sendErrorResponse(error.message);
                }
            }
        });

        // å¤„ç†æ–°æ ¼å¼æ¶ˆæ¯
        async function processNewFormat(apiUrl, headers, body) {
            console.log('ğŸ”„ å¤„ç†æ–°æ ¼å¼APIè¯·æ±‚:', { apiUrl });
            return await makeProxyRequest(apiUrl, 'POST', headers, JSON.stringify(body));
        }

        // å¤„ç†æ—§æ ¼å¼æ¶ˆæ¯
        async function processOldFormat(payload) {
            const { url, method, headers, body } = payload;
            console.log('ğŸ”„ å¤„ç†æ—§æ ¼å¼APIè¯·æ±‚:', { url, method });
            return await makeProxyRequest(url, method || 'POST', headers || {}, body);
        }

        // æ‰§è¡Œä»£ç†è¯·æ±‚
        async function makeProxyRequest(url, method, headers, body) {
            console.log('ğŸŒ å¼€å§‹ä»£ç†è¯·æ±‚:', { url, method });
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºOpenAI API
            if (url.includes('api.openai.com')) {
                console.log('ğŸ¤– æ£€æµ‹åˆ°OpenAI APIï¼Œç›´æ¥è¯·æ±‚...');
                return await directRequest(url, method, headers, body);
            }
            
            // å¯¹äºå…¶ä»–APIï¼ˆå¦‚Anthropicï¼‰ï¼Œä½¿ç”¨CORSä»£ç†
            console.log('ğŸ”§ ä½¿ç”¨CORSä»£ç†å¤„ç†è¯·æ±‚...');
            let lastError = null;
            
            for (const proxy of CORS_PROXIES) {
                try {
                    console.log(`ğŸ“¡ å°è¯•ä»£ç†: ${proxy.name}`);
                    
                    const proxyUrl = proxy.url + url;
                    const proxyHeaders = {
                        ...headers,
                        ...proxy.headers
                    };
                    
                    const response = await fetch(proxyUrl, {
                        method: method,
                        headers: proxyHeaders,
                        body: method !== 'GET' ? body : undefined
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`âœ… ${proxy.name} ä»£ç†æˆåŠŸ!`);
                        return data;
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (error) {
                    console.warn(`âš ï¸ ${proxy.name} ä»£ç†å¤±è´¥:`, error.message);
                    lastError = error;
                    continue;
                }
            }
            
            throw new Error(`æ‰€æœ‰ä»£ç†éƒ½å¤±è´¥äº†ã€‚æœ€åé”™è¯¯: ${lastError?.message}`);
        }

        // ç›´æ¥è¯·æ±‚ï¼ˆç”¨äºOpenAI APIï¼‰
        async function directRequest(url, method, headers, body) {
            const response = await fetch(url, {
                method: method,
                headers: headers,
                body: method !== 'GET' ? body : undefined
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            return await response.json();
        }

        // å‘é€æˆåŠŸå“åº”
        function sendSuccessResponse(data) {
            const response = {
                type: 'API_RESPONSE',
                success: true,
                data: data
            };
            
            console.log('âœ… å‘é€æˆåŠŸå“åº”');
            parent.postMessage(response, "*");
        }

        // å‘é€é”™è¯¯å“åº”
        function sendErrorResponse(errorMessage) {
            const response = {
                type: 'API_RESPONSE',
                success: false,
                error: errorMessage
            };
            
            console.log('âŒ å‘é€é”™è¯¯å“åº”:', errorMessage);
            parent.postMessage(response, "*");
        }

        // é¡µé¢åŠ è½½å®Œæˆåé€šçŸ¥æ’ä»¶
        window.addEventListener('load', () => {
            console.log('âœ… APIä»£ç†v2.4.1å‡†å¤‡å°±ç»ª');
            parent.postMessage({
                type: 'PROXY_READY',
                version: 'v2.4.1',
                message: 'APIä»£ç†å·²å‡†å¤‡å°±ç»ª'
            }, "*");
        });
    </script>
</body>
</html>
